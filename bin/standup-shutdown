#!/usr/bin/env bash
# AI Standup Shutdown - Gracefully shuts down all roles with session summaries
# Usage: standup-shutdown [--force]

set -e

# Require Bash 4.0 or higher for associative arrays
if ((BASH_VERSINFO[0] < 4)); then
    echo "Error: This script requires Bash 4.0 or higher (you have $BASH_VERSION)"
    exit 1
fi

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BOLD='\033[1m'
NC='\033[0m'

# Determine project root and name
PROJECT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
PROJECT_NAME="$(basename "$PROJECT_ROOT")"
STANDUP_DIR="$PROJECT_ROOT/.standup"
TODAY=$(date +%Y-%m-%d)
TIME=$(date +%H:%M)

# Parse arguments
FORCE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --force|-f)
            FORCE=true
            shift
            ;;
        -h|--help)
            echo "AI Standup Shutdown"
            echo "Usage: $0 [options]"
            echo ""
            echo "Options:"
            echo "  --force, -f    Skip summary prompts and force immediate shutdown"
            echo "  -h, --help     Show this help message"
            exit 0
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            echo "Use -h for help"
            exit 1
            ;;
    esac
done

# Role definitions
declare -A ROLES=(
    ["architect"]="Architect (System Designer)"
    ["developer"]="Developer (Bug Fixer)"
    ["qa-engineer"]="QA Engineer"
    ["code-reviewer"]="Code Reviewer"
)

ROLE_ORDER=("architect" "developer" "qa-engineer" "code-reviewer")

# Find the standup tmux session
find_standup_session() {
    tmux list-sessions -F "#{session_name}" 2>/dev/null | grep "^standup-$PROJECT_NAME" | head -1
}

# Get window index for a session
get_window_index() {
    local session=$1
    tmux list-windows -t "$session" -F "#{window_index}" 2>/dev/null | head -1
}

# Send shutdown prompt to a pane
send_shutdown_prompt() {
    local session=$1
    local window=$2
    local pane=$3
    local role=$4
    local summary_file="$STANDUP_DIR/$role/session-summary-$TODAY.md"
    
    # Create the shutdown prompt
    local prompt="

---
## SESSION ENDING - Please provide your end-of-session summary

Before this session closes, please:

1. **Update your daily log** (\`.standup/$role/log-$TODAY.md\`) with:
   - What you accomplished this session
   - Any work in progress
   - Blockers or issues encountered

2. **Create a session summary** by writing to \`.standup/$role/session-summary-$TODAY.md\`:
   - Key accomplishments
   - Files modified
   - PRs created/reviewed
   - Recommendations for next session

3. **Update tasks.json** with current task statuses

4. **Post any handoff notes** to \`.standup/notifications.md\` for other roles

Please complete these updates now. The session will close in 5 minutes.
Type 'done' when you've finished your summary.
---
"
    
    # Send the prompt to the pane
    tmux send-keys -t "$session:$window.$pane" "$prompt" Enter
}

# Wait for role to complete summary (with timeout)
wait_for_completion() {
    local session=$1
    local window=$2
    local pane=$3
    local role=$4
    local timeout=300  # 5 minutes
    local elapsed=0
    local check_interval=10
    
    echo -e "  ${YELLOW}Waiting for ${ROLES[$role]} to complete summary...${NC}"
    
    while [ $elapsed -lt $timeout ]; do
        # Check if the summary file was updated recently (within last 2 minutes)
        local summary_file="$STANDUP_DIR/$role/session-summary-$TODAY.md"
        if [[ -f "$summary_file" ]]; then
            local file_age=$(($(date +%s) - $(stat -f %m "$summary_file" 2>/dev/null || stat -c %Y "$summary_file" 2>/dev/null || echo 0)))
            if [ $file_age -lt 120 ]; then
                echo -e "  ${GREEN}âœ“ ${ROLES[$role]} completed summary${NC}"
                return 0
            fi
        fi
        
        sleep $check_interval
        elapsed=$((elapsed + check_interval))
        echo -e "  ${YELLOW}  Still waiting... ($elapsed/${timeout}s)${NC}"
    done
    
    echo -e "  ${YELLOW}âš  Timeout waiting for ${ROLES[$role]} - proceeding with shutdown${NC}"
    return 1
}

# Create final session report
create_final_report() {
    local report_file="$STANDUP_DIR/session-report-$TODAY-$TIME.md"
    
    cat > "$report_file" <<EOF
# Session Report - $TODAY $TIME

## Session Duration
Started: $(cat "$STANDUP_DIR/.session-start" 2>/dev/null || echo "Unknown")
Ended: $TODAY $TIME

## Role Summaries

EOF
    
    for role in "${ROLE_ORDER[@]}"; do
        local summary_file="$STANDUP_DIR/$role/session-summary-$TODAY.md"
        echo "### ${ROLES[$role]}" >> "$report_file"
        echo "" >> "$report_file"
        
        if [[ -f "$summary_file" ]]; then
            cat "$summary_file" >> "$report_file"
        else
            echo "_No summary provided_" >> "$report_file"
        fi
        echo "" >> "$report_file"
        echo "---" >> "$report_file"
        echo "" >> "$report_file"
    done
    
    echo -e "${GREEN}âœ“ Session report saved to: $report_file${NC}"
}

# Clean up tmux session
cleanup_tmux() {
    local session=$1
    
    echo -e "${BLUE}Cleaning up tmux session...${NC}"
    
    if tmux has-session -t "$session" 2>/dev/null; then
        tmux kill-session -t "$session"
        echo -e "${GREEN}âœ“ Killed tmux session: $session${NC}"
    else
        echo -e "${YELLOW}Session already closed${NC}"
    fi
}

# Main shutdown process
main() {
    echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${BOLD}â•‘          AI Standup - Graceful Shutdown                â•‘${NC}"
    echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo
    
    # Check if standup directory exists
    if [[ ! -d "$STANDUP_DIR" ]]; then
        echo -e "${RED}Error: No standup directory found at $STANDUP_DIR${NC}"
        echo "Are you in the right project directory?"
        exit 1
    fi
    
    # Find the tmux session
    local session=$(find_standup_session)
    
    if [[ -z "$session" ]]; then
        echo -e "${YELLOW}No active standup session found for project: $PROJECT_NAME${NC}"
        echo ""
        echo "Available tmux sessions:"
        tmux list-sessions 2>/dev/null || echo "  (none)"
        echo ""
        echo -e "${BLUE}Tip: If sessions exist but aren't named correctly, use:${NC}"
        echo "  tmux kill-session -t <session-name>"
        exit 0
    fi
    
    echo -e "${BLUE}Found session:${NC} $session"
    echo -e "${BLUE}Project:${NC} $PROJECT_NAME"
    echo -e "${BLUE}Standup dir:${NC} $STANDUP_DIR"
    echo
    
    local window=$(get_window_index "$session")
    
    if [[ "$FORCE" == "true" ]]; then
        echo -e "${YELLOW}Force shutdown requested - skipping summary prompts${NC}"
        echo
    else
        # Confirm shutdown
        echo -e "${YELLOW}This will:${NC}"
        echo "  1. Send shutdown prompts to all roles"
        echo "  2. Wait up to 5 minutes for each role to create summaries"
        echo "  3. Generate a final session report"
        echo "  4. Clean up the tmux session"
        echo
        read -p "Proceed with graceful shutdown? [y/N] " -n 1 -r
        echo
        
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo -e "${YELLOW}Shutdown cancelled${NC}"
            exit 0
        fi
        
        echo
        echo -e "${BOLD}Sending shutdown prompts to all roles...${NC}"
        echo
        
        # Send shutdown prompts to all panes
        local pane_idx=0
        for role in "${ROLE_ORDER[@]}"; do
            echo -e "${BLUE}Notifying ${ROLES[$role]}...${NC}"
            send_shutdown_prompt "$session" "$window" "$pane_idx" "$role"
            ((pane_idx++))
        done
        
        echo
        echo -e "${BOLD}Waiting for roles to complete summaries...${NC}"
        echo -e "${YELLOW}(Timeout: 5 minutes per role)${NC}"
        echo
        
        # Wait for each role to complete (in parallel would be nice, but sequential is simpler)
        pane_idx=0
        for role in "${ROLE_ORDER[@]}"; do
            wait_for_completion "$session" "$window" "$pane_idx" "$role"
            ((pane_idx++))
        done
        
        echo
    fi
    
    # Create final report
    echo -e "${BOLD}Creating session report...${NC}"
    create_final_report
    
    # Clean up tmux
    echo
    cleanup_tmux "$session"
    
    # Add shutdown note to notifications
    cat >> "$STANDUP_DIR/notifications.md" <<EOF

---

## ðŸ”µ SESSION ENDED - $TODAY $TIME

All roles have been shut down gracefully.
Session report saved to: session-report-$TODAY-$TIME.md

---

EOF
    
    echo
    echo -e "${GREEN}${BOLD}âœ“ Standup session ended successfully!${NC}"
    echo
    echo -e "${BOLD}Session artifacts:${NC}"
    echo "  â€¢ Session report: $STANDUP_DIR/session-report-$TODAY-$TIME.md"
    echo "  â€¢ Role summaries: $STANDUP_DIR/<role>/session-summary-$TODAY.md"
    echo "  â€¢ Daily logs: $STANDUP_DIR/<role>/log-$TODAY.md"
    echo
    echo -e "${BLUE}To start a new session tomorrow, run:${NC}"
    echo "  standup"
}

main "$@"
